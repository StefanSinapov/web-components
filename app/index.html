<!doctype html>
<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<html lang="bg">

<head>
  <meta charset="utf-8">
  <meta name="description" content="Реферат на тема Уеб компоненти. web components, shadow dom, custom elements, templates, template element, html import">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="generator" content="Web Components">
  <title>Web Components</title>

  <!-- Place favicon.ico in the `app/` directory -->

  <!-- Chrome for Android theme color -->
  <meta name="theme-color" content="#2E3AA1">

  <!-- Web Application Manifest -->
  <link rel="manifest" href="manifest.json">

  <!-- Tile color for Win8 -->
  <meta name="msapplication-TileColor" content="#3372DF">

  <!-- Add to homescreen for Chrome on Android -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="application-name" content="PSK">
  <link rel="icon" sizes="192x192" href="images/touch/chrome-touch-icon-192x192.png">

  <!-- Add to homescreen for Safari on iOS -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Web Components">
  <link rel="apple-touch-icon" href="images/touch/apple-touch-icon.png">

  <!-- Tile icon for Win8 (144x144) -->
  <meta name="msapplication-TileImage" content="images/touch/ms-touch-icon-144x144-precomposed.png">

  <!-- build:css styles/main.css -->
  <link rel="stylesheet" href="styles/main.css">
  <!-- endbuild-->

  <!-- build:js bower_components/webcomponentsjs/webcomponents-lite.min.js -->
  <script src="bower_components/webcomponentsjs/webcomponents-lite.js"></script>
  <!-- endbuild -->

  <!-- Because this project uses vulcanize this should be your only html import
       in this file. All other imports should go in elements.html -->
  <link rel="import" href="elements/elements.html">

  <!-- For shared styles, shared-styles.html import in elements.html -->
  <style is="custom-style" include="shared-styles"></style>
</head>

<body unresolved>
  <!-- build:remove -->
  <span id="browser-sync-binding"></span>
  <!-- endbuild -->

  <template is="dom-bind" id="app">

    <paper-drawer-panel id="paperDrawerPanel">
      <!-- Drawer Scroll Header Panel -->
      <paper-scroll-header-panel drawer fixed>

        <!-- Drawer Toolbar -->
        <paper-toolbar id="drawerToolbar">
          <span class="menu-name">Web Components</span>
        </paper-toolbar>

        <!-- Drawer Content -->
        <paper-menu class="app-menu" attr-for-selected="data-route" selected="[[route]]">
          <!--<a data-route="home" href="{{baseUrl}}">
            <iron-icon icon="home"></iron-icon>
            <span>Home</span>
          </a>

          <a data-route="users" href="{{baseUrl}}users">
            <iron-icon icon="info"></iron-icon>
            <span>Users</span>
          </a>

          <a data-route="contact" href="{{baseUrl}}contact">
            <iron-icon icon="mail"></iron-icon>
            <span>Contact</span>
          </a>
          -->
          <a data-route="introduction" href="{{baseUrl}}introduction">
            <iron-icon src="images/icons/web-components_48x48.png"></iron-icon>
            <span>Въведение</span>
          </a>

          <a data-route="templates" href="{{baseUrl}}templates">
            <iron-icon src="images/icons/templates_48x48.png"></iron-icon>
            <span>Templates</span>
          </a>

          <a data-route="custom-elements" href="{{baseUrl}}custom-elements">
            <iron-icon src="images/icons/custom-elements_48x48.png"></iron-icon>
            <span>Custom Elements</span>
          </a>

          <a data-route="shadow-dom" href="{{baseUrl}}shadow-dom">
            <iron-icon src="images/icons/shadow-dom_48x48.png"></iron-icon>
            <span>Shadow Dom</span>
          </a>

          <a data-route="html-imports" href="{{baseUrl}}html-imports">
            <iron-icon src="images/icons/html-imports_48x48.png"></iron-icon>
            <span>HTML Imports</span>
          </a>

          <a data-route="browser-support" href="{{baseUrl}}browser-support">
            <iron-icon icon="build"></iron-icon>
            <span>Browser Support</span>
          </a>

          <a data-route="resources" href="{{baseUrl}}resources">
            <iron-icon icon="language"></iron-icon>
            <span>Resources</span>
          </a>

          <a data-route="about-me" href="{{baseUrl}}about-me">
            <iron-icon icon="account-circle"></iron-icon>
            <span>About me</span>
          </a>
        </paper-menu>
      </paper-scroll-header-panel>

      <!-- Main Area -->
      <paper-scroll-header-panel main id="headerPanelMain" condenses keep-condensed-header>
        <!-- Main Toolbar -->
        <paper-toolbar id="mainToolbar" class="tall">
          <paper-icon-button id="paperToggle" icon="menu" paper-drawer-toggle></paper-icon-button>

          <span class="space"></span>

          <!-- Toolbar icons -->
          <!--<paper-icon-button icon="search"></paper-icon-button>-->

          <!-- Application name -->
          <div class="middle middle-container">
            <div class="app-name">{{title}}</div>
          </div>

          <!-- Application sub title -->
          <div class="bottom bottom-container">
            <div class="bottom-title">{{subTitle}}</div>
          </div>
        </paper-toolbar>

        <!-- Main Content -->
        <div class="content">
          <iron-pages attr-for-selected="data-route" selected="{{route}}">
            <section data-route="home" tabindex="-1">
              <paper-material elevation="1">
                <my-greeting></my-greeting>

                <p class="subhead">You now have:</p>
                <my-list></my-list>

                <p>Looking for more Web App layouts? Check out our <a href="https://github.com/PolymerElements/app-layout-templates">layouts</a>                  collection. You can also <a href="http://polymerelements.github.io/app-layout-templates/">preview</a> them
                  live.
                </p>
              </paper-material>

              <paper-material elevation="1">
                <p>This is another card.</p>
              </paper-material>

              <paper-material elevation="1">
                <h2 id="license">License</h2>
                <p>Everything in this repo is BSD style license unless otherwise specified.</p>
                <p>Copyright (c) 2015 The Polymer Authors. All rights reserved.</p>
                <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that
                  the following conditions are met:</p>
                <ul>
                  <li>Redistributions of source code must retain the above copyright notice, this list of conditions and the
                    following disclaimer.</li>
                  <li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
                    following disclaimer in the documentation and/or other materials provided with the distribution.
                  </li>
                  <li>Neither the name of Google Inc. nor the names of its contributors may be used to endorse or promote products
                    derived from this software without specific prior written permission.</li>
                </ul>
                <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
                  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
                  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
                  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
                  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
                  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
                  OF SUCH DAMAGE.</p>
              </paper-material>
            </section>

            <section data-route="contact" tabindex="-1">
              <paper-material elevation="1">
                <h1 class="page-title" tabindex="-1">Contact</h1>
                <p>This is the contact section</p>
              </paper-material>
            </section>

            <section data-route="introduction" tabindex="-1">
              <paper-material elavation="1">
                <h1 class="page-title" tabindex="-1">Въведение</h1>
                <p>
                  Нови технологии излизат всеки ден, повечето от тях с обещание, че чрез тях много по-лесно и по-бързо ще могат да се създадат
                  комплексни уеб приложение, какво тогава прави уеб компонентите толкова специални? Ако погледнем към инвестициите
                  които правят големи компании, като Google например с Polymer, или Mozilla с техният X-Tag, ще можем да
                  видим, че уеб компонентите неотменно ще бъдат част от бъдещето на уеб технологиите.
                </p>

                <h2 class="subhead">Какво са уеб компонентите?</h2>
                <p>
                  "Уеб компоненти" е термин който обобщава набор от технологии с помощта на които програмистите могат да създават компоненти
                  които лесно и бързо да бъдат преизползвани.
                </p>
                <p>Технологиите които седят зад уеб компонентите са: html templates, custom elements, shadow DOM и HTML imports.</p>
                <p>Съществуващите уеб компоненти са част от браузъра и могат да се използват без писане на код, а само чрез
                  добавяне на import в HTML страницата.</p>
                <p>
                  В момента уеб компонентите са в ранна фаза на документиране от W3C стандартът, но се поддържа в браузъри като Google Chrome,
                  Opera и Mozilla Firefox. А чрез polyfills дори и в по-стари браузъри.
                </p>
                <p>Всичко звучи много добре, но с какво на практика се различава от досегашният начин за преизползване на библиотеки.</p>
                <p>Добър пример за това е jQuery UI. Ето например как можем да добавим модален прозорец в приложението си използвайки
                  jQuery UI:</p>
                <prism-highlighter></prism-highlighter>
                <marked-element>
                  <div class="markdown-html"></div>
                  <script type="text/markdown">
                    ```html
                    <!-- based on http://jqueryui.com/dialog/ -->
                    <head>
                      <link	rel='stylesheet' href='//code.jquery.com/ui/1.11.0/themes/smoothness/jquery-ui.css' />
                    </head>
                      <script src="//code.jquery.com/jquery-1.10.2.js"></script1>
                      <script src="//code.jquery.com/ui/1.11.0/jquery-ui.js"></script2>
                      <script>
                        $(function () {
                          $( "#dialog" ).dialog();
                        }); 
                      </script3>
                    <body>
                        <div id="dialog" title="After Ford">
                          Ending is better than mending. <br />
                          The more stitches, the less riches.
                        </div>
                    </body>
                    ```
                    </script>
                </marked-element>

                <p>Изглежда просто нали, 3 script тага с импорти и още един за инициализирането на самият елемент като модален
                  прозорец.
                </p>
                <p>Нека видим сега как би изглеждало това чрез уеб компоненти:</p>
                <marked-element>
                  <div class="markdown-html"></div>
                  <script type="text/markdown">
                      ```html
                      <head>
                        <link rel="import" href="/imports/dialog/index.html">
                      </head>
                      <body>
                        <dialog-component title="After Ford">
                          Ending is better than mending. <br />
                          The more stitches, the less riches.
                        </dialog-component>
                      </body>
                      ```
                    </script>
                </marked-element>
                <p> Това значително подобри четливостта на кода нали? Но не това е най-важното в случая, а в знанията които са
                  необходими за да се използват двата компонента. В първия случай трябва да знаем API-то на jQueryUI, а при
                  втория уеб компонентите използват подход подобен на този на DOM API-то с който повечето програмисти са
                  запознати.
                </p>
                <p>
                  Разликите не изглеждат толкова големи, но когато започнем да работим с повече UI библиотеки, като например jQuery UI, Bootstrap,
                  Closure Libraries и т.н., всички използват различни терминологии и подходи и ще трябва да научите първо
                  тях преди реално да започнете да ги използвате.
                </p>
              </paper-material>
              <paper-material>
                <h3>Има и други преимущества от използването на уеб компоненти: </h3>
                <ol>
                  <li>
                    <p>
                      Kато например <strong>изолираният обхват (scope) на css стиловете</strong>. При обикновените UI библиотеки
                      е възможно самата библиотека вътрешно да добавя css class или Id което и ние да използваме в проекта
                      си, при което може да се получи изтичане (leak) на стилове. При уеб компонентите няма такава опасност,
                      защото CSS стиловете имат обхват елементът. Това означава, че стиловете които идват с компонента няма
                      как да имат някакъв страничен ефект върху бащините елементи. Същото е и в обратна посока, предотвратява
                      parent документа случайно да стилизира уеб компонента.
                    </p>
                  </li>
                  <li>
                    <p>
                      <strong>Преизползваемост</strong>. Поради това, че уеб компонентите са с изолиран обхват и отделени
                      от останалата част на уеб страницата, те могат да бъдат преизползвани на други места в приложението.
                      Или дори да бъдат споделени като open source елементи, където всеки би могъл да ги използва.
                    </p>
                  </li>
                  <li>
                    <p>
                      <strong>Изолираност</strong>. Тъй като уеб компонентите са с изолиран обхват (scope), разработването
                      на UI компонентите може да бъде отделно от основната функционалност на приложението. Програмистите
                      може самостоятелно да работят върху UI компонента, без да се налага да са наясно с логиката в останалата
                      част на приложението. Поддръжката на тези компонента също е по-лесна поради изолираността им.
                    </p>
                  </li>
                </ol>
              </paper-material>

            </section>

            <section data-route="templates" tabindex="-1">
              <paper-material elavation="1">
                <h1 class="page-title" tabindex="-1">Templates</h1>
                <p>
                  Идеята за темплейти(шаблони) не е нещо ново.
                  <br/> Използва се от много време както на сървъра (server side) така и при клиента (client side).
                </p>
                <p>
                  Започвайки от сървъра темплейтите са широко разпространени за присвояване на променливи, условни операции и повтаряне на
                  съдържание в HTML.
                </p>
                <p>
                  Клиентски същото е постигнато от множество библиотеки чрез JavaScript: Handlebars.js, Underscore.js, AngularJS, Mustache
                  и т.н.
                  <br> Всички те работят добре, но техниките които използват си имат своите недостатъци.
                </p>
                <p>
                  В този пример шаблонът е div елемент скрит с помощта на стилове.
                </p>
                <prism-highlighter></prism-highlighter>
                <marked-element>
                  <div class="markdown-html"></div>
                  <script type="text/markdown">
                    ```html
                      <div style="display: none">
                        <div>
                          <h1>Web Components</h1>
                          <img src="http://webcomponents.org/img/logo.svg"/>
                        </div>
                      </div> 
                    ```
                    Недостига на този начин е, че браузъра ще извлече всички ресурси, като например картинката дори и ако шаблонът все още не е използван. Това е загуба на ресурси и производителност.

                    Друг използван начин е шаблона да бъде в script елемент с невалиден тип.
                    ```html
                    <script type="text/template">
                      <div>
                        <h1>Web Components</h1>
                        <img src="http://webcomponents.org/img/logo.svg"/>
                      </div>
                    </script1>
                    ```
                    Недостиг на този начин е, че понеже този шаблон ще бъде превърнат в DOM елемент чрез javascript InnerHtml api-то, може да доведе до cross site script уязвимост ако не е извършена подходяща проверка на съдържанието.                    
                    
                    
                    <strong>Template</strong> елементът ще реши този проблем
                    ```html
                    <template>
                      <div>
                        <h1>Web Components<h1>
                        <img src="http://webcomponents.org/img/logo.svg">
                      </div>
                    </template>
                    ```
                  </script>
                </marked-element>
                <p>
                  Той позволява да се декларират фрагменти от html елементи, които са анализирани (parse) като HTML, но остават неизползвани
                  по време на изпълнение и могат да бъдат истанцирани по-късно, когато има нужда от тях.
                  <br> Темплейт елементът няма да изпълни съдържанието си, няма да направи заявка към други ресурси като
                  картинки или скриптове и няма да изпълни <code>script</code> тагове декларирани в тях.
                </p>
              </paper-material>
              <paper-material>
                <h4>Поддръжка</h4>
                <p>
                  В момента template елементът се поддържа от Chrome, Firefox и Opera.
                  <br/> Очаква се във версия 8 на Safari.
                  <br/> Повече за поддръжката може да намерите на този адрес: <a href="https://www.chromestatus.com/features/5207287069147136"
                    target="_blank">https://www.chromestatus.com/features/5207287069147136</a>
                </p>
                <p>
                  За проверка дали браузъра в който в момента е отворена страницата поддържа template елементът може да се използва следния
                  код.
                </p>
                <prism-highlighter></prism-highlighter>
                <marked-element>
                  <div class="markdown-html"></div>
                  <script type="text/markdown">
                    ```js
                      if(!window.HTMLTemplateElement){    
                       ... 
                      }
                    ```
                    </script>
                </marked-element>
                <p>Повече информация за поддръжката в различни браузъри може да намерите в секцията
                  <a data-route="browser-support" href="{{baseUrl}}browser-support">Browser Support</a>.</p>
              </paper-material>

              <paper-material>
                <h4>
                  Писането на собствен темплейт:
                </h4>
                <prism-highlighter></prism-highlighter>
                <marked-element>
                  <div class="markdown-html"></div>
                  <script type="text/markdown">
                    Първо декларираме съдържанието
                    ```html
                    <template>
                      <style>
                        ...
                      </style>
                      <div>
                        <h1>Web Components<h1>
                        <img src="http://webcomponents.org/img/logo.svg">
                      </div>
                    </template>
                    ```
                    За да визуализираме съдържанието на темплейта са необходими няколко реда javascript код:
                    ```html
                    <script>
                        var template = document.querySelector('#template');
                        var clone = document.importNode(template.content, true);
                        var host = document.qurySelector('#host');
                        host.appendChild(clone);
                    </script1>
                    <div id="host"></div>
                    ```
                    </script>
                </marked-element>
              </paper-material>
              <paper-material>
                <h4>Допълнителна информация</h4>
                <p>
                  За да научите повече за template елементът може да прочетете статията на
                  <a href="http://www.html5rocks.com/en/tutorials/webcomponents/template/" target="_blank">
                  Eric Bindelman - HTML's new template tag</a> [1]
                </p>
              </paper-material>
            </section>

            <section data-route="custom-elements" tabindex="-1">
              <paper-material elavation="1">
                <h1 class="page-title" tabindex="-1">Custom Elements</h1>
                <p>
                  Персонализираните елементи са тази част от уеб компонентите, която позволява създаването на свои собствени HTML тагове.
                </p>
                <p>
                  Първоначално HTML е създаден за описание на документи чрез специални елементи или тагове. Но той има ограничен речник, което
                  означава, че в крайна сметка описанието на документа се свежда до комбинация от div и span елементи.
                </p>
                <p>
                  Персонализираните елементи могат да променят това.
                  <br/> Някои библиотеки, като AngularJs, вече предлагат начин за дефиниране на персонализирани елементи,
                  но те са специфични за библиотеката и не могат да бъдат преизползвани.
                </p>
                <p>С персонализирани елементи, може да се дефинират и регистрират нови DOM елементи</p>
                <prism-highlighter></prism-highlighter>
                <marked-element>
                  <div class="markdown-html"></div>
                  <script type="text/markdown">
                    ```html
                    <x-component></x-component>
                    ```

                    Както и да се наследят и разширят вече съществуващи такива. 
                    ```html
                    <div is="x-component"><div>
                    ```
                  </script>
                </marked-element>
                <p>
                  По този начин се улесняват както авторите на тези елементи, така и разработчиците които след това ще ги използват.
                </p>
              </paper-material>
              <paper-material>
                <h2>Поддръжка</h2>
                <p>
                  Персонализираните елементи се поддържат в Chrome и Opera, както и Firefox също след настройка (флаг).
                </p>
                <prism-highlighter></prism-highlighter>
                <marked-element>
                  <div class="markdown-html"></div>
                  <script type="text/markdown">
                    За проверка дали е наличен в текущия браузър може да се провери дали съществува document.registerElement 
                    ```js
                      if(!document.registerElement){
                        ...
                      }
                    ```
                  </script>
                </marked-element>
              </paper-material>
              <paper-material>
                <h2>Начин на използване.</h2>
                <prism-highlighter></prism-highlighter>
                <marked-element>
                  <div class="markdown-html"></div>
                  <script type="text/markdown">
                    <strong>JavaScript:</strong> 
                    ```js
                    var XComponent = document.registerElement('x-component')
                    ```
                    <strong>HTML:</strong>
                    ```html
                    <x-component></x-component>
                    ```
                    
                    Името на елемента трябва да бъде разделено с тире (-), всичко друго би довело до грешка.
                    
                    Тези нови елементи могат да се използват не само декларативно в html-a, 
                    но и императивно, използвайки JavaScript. 

                    Единият от начините е да се използва персонализирания елемент е чрез инициализиране на конструктора:
                    ```js
                    var XComponent = document.registerElement('x-component');
                    var dom = new XComponent();
                    document.body.appendChild(dom);
                    ```
                    
                    Или понеже персонализираните елементи са точно като всеки друг 
                    HTML елемент може да се използва `document.CreateElement`
                    ```js
                    document.registerElement('x-component');
                    var dom = document.createElement('x-component');
                    document.body.appendChild(dom);
                    ```
                    
                    Допълнителна функционалност може да бъде добавена към персонализираните
                    елементи като се наследи прототипът на съществуващ елемент.
                    
                    Първо се създава нов обект от HTML прототип чрез използване на `Object.create`
                    ```js
                    var proto = Object.create(HTMLElement.prototype)
                    proto.createCallback = function() {
                        this.textContent = 'FMI \o/';
                    }
                    document.registerElement('fmi', {
                        prototype: proto
                    });
                    ```
                    ```html
                    <fmi></fmi>
                    ```
                  </script>
                </marked-element>
              </paper-material>
              <paper-material>
                <h2>Разширяване на съществуващ елемент.</h2>
                <prism-highlighter></prism-highlighter>
                <marked-element>
                  <div class="markdown-html"></div>
                  <script type="text/markdown">
                    Възможно е също така да се разшири даден елемент.
                    ```js
                    var Fmi = document.registerElement('fmi', {
                        extends:
                        prototype: Object.create( ... )
                    });
                    ```
                    
                    Така може да се разшири вече съществуващ елемент като `HTMLImputElement` например:
                    ```js
                    var Fmi = document.registerElement('fmi', {
                        extends:
                        prototype: Object.create(HTMLImputElement.prototype)
                    });
                    ```
                    За да се използва новият разширен елемент трябва да се добави като стойност на `is` атрибута в съществуващият елемент.
                    ```html
                    <input is='fmi'/>
                    ```
                    
                    А императивното използване в JavaScript става чрез подаване като втори аргумент в `document.CreateElement` функцията
                    ```js
                    var el = document.createElement('input', 'fmi');
                    ```
                  </script>
                </marked-element>
                <p>
                  Пример за разширяването на вече съществуващ елемент може да се намери на сайта на Github.
                </p>
                <img class="responsive" src="images/custom_elements_01.png" />
                <p>Ако проверим кода на този елемент чрез dev tools ще видим, че това е date елемент</p>
                <img class="responsive" src="images/custom_elements_02.png" />
                <p>Повече за time-element може да намерите на
                  <a href="https://github.com/github/time-elements">https://github.com/github/time-elements</a>
                </p>
              </paper-material>
              <paper-material>
                <h2>Lifecycle events</h2>
                <prism-highlighter></prism-highlighter>
                <marked-element>
                  <div class="markdown-html"></div>
                  <script type="text/markdown">
                    Персонализираните елементи поддържат lifecycle събития,
                    което позволява манипулирането на DOM на определени интервали. 
                    
                    Съществуват 4 такива събития:
                     - при създаване - `.createdCallback()`
                     - добавяне към DOM - `.attachedCallback()`
                     - премахване от DOM - `.detachedCallback()`
                     - при промяна на атрибут - `.attributeChangedCallback()`
                     
                     Използването на тези събития става чрез добавянето им към прототипа на елемент
                     ```js
                      var proto = Object.create(HTMLElement.prototype)
                      proto.createdCallback = function(){
                          var div = document.createElement('div');
                          div.textContent = 'This is my Custom Element';
                          this.appendChild(div);
                      };
                      var XComponent = document.registerElement('x-component', {
                          prototype: proto
                      }); 
                      ```
                  </script>
                </marked-element>
              </paper-material>
              <paper-material>
                <h2>Допълнителна информация</h2>
                <p>Повече информация за персонализираните елементи може да намерите на:</p>
                <p>
                  [2] Eric Bidelman - Custom Elements - <a href="http://www.html5rocks.com/en/tutorials/webcomponents/customelements/">
                  http://www.html5rocks.com/en/tutorials/webcomponents/customelements/</a>
                </p>
                <p>
                  [3] MDN - Custom Elements -
                  <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Custom_Elements">https://developer.mozilla.org/en-US/docs/Web/Web_Components/Custom_Elements</a>
                </p>
              </paper-material>
            </section>

            <section data-route="shadow-dom" tabindex="-1">
              <paper-material elavation="1">
                <h1 class="page-title" tabindex="-1">Shadow DOM</h1>
                <p>
                  Shadow DOM предоставя начин за добавяне на вътрешно DOM дърво в друг DOM елементи с изолирани стилове от останалата част
                  от уеб страницата.
                </p>
                <p>
                  Точно така са имплементирани новите html 5 елементи като <code>video, audio и input type='date'</code>
                </p>
                <p>
                  Нека погледнем следния пример.
                  <br> Първо за да позволите браузъра ви да вижда Shadow DOM отворете Chrome DevTools и отидете на Settings
                  или натиснете F1. Маркирайте опцията Show user agent shadow DOM.
                </p>
                <img class="responsive" src="images/shadow_dom_01.png" />
                <p>
                  След което когато разпънем video тагът ще можем да видим как браузъра е го е имплементирал.
                </p>
                <img class="responsive" src="images/shadow_dom_02.png" />
                <img class="responsive" src="images/shadow_dom_03.png" />
                <p>
                  По този начин например са добави контролите за старт и пауза към video елементът. По същият начин shadow DOM може да бъде
                  използван и за изграждане на нови компоненти.
                </p>
              </paper-material>
              <paper-material>
                <h2>Поддръжка</h2>
                <p>
                  Към момента shadow DOM се поддържа от Chrome и Opera, както и от Firefox след настройка (флаг). За останалите браузъри съществува
                  polyfill.
                </p>
                <p>
                  За проверка дали текущият браузър поддържа shadow DOM може да се провери дали
                  <code>document.body.createSHadowRoot</code> съществува.
                </p>
                <prism-highlighter></prism-highlighter>
                <marked-element>
                  <div class="markdown-html"></div>
                  <script type="text/markdown">
                    ```js
                    if(!document.body.createShadowRoot) {
                      ...
                    }
                    ```
                  </script>
                </marked-element>
              </paper-material>
              <paper-material>
                <p>
                  Чрез shadow DOM елемент може да получи нов тип възел (node) наречен shadow root. Един елемент, който има shadow root свързан
                  с него се нарича shadow host.
                </p>
                <img class="responsive" src="images/shadow_dom_04.png" />
                <p>
                  Shadow root може да бъде разглеждам като обикновен DOM елемент, така че към него могат да бъдат добавяни други елементи.
                </p>
                <p>
                  Чрез shadow DOM всичките CSS стилове са вътрешни и не могат да променят елементи извън него. Също така shadow DOM пречи на
                  стилове от по-външен (бащин) елемент да променят стилизацията на съдържанието на shadow host-a.
                </p>
                <img class="responsive" src="images/shadow_dom_05.png" />
                <p>
                  Това означава, че css дефиниран в shadow root няма да изтече (leak) и промени стилизацията на елементи извън shadow root-a,
                  както и обратното, стилове дефинирани в head частта на уеб страницата няма случайно да променят стилизацията
                  на уеб компонента.
                </p>
              </paper-material>
              <paper-material>
                <h2>Начин на използване.</h2>
                <p>
                  За да се създаде shadow root трябва да се викне <code>createShadowRoot()</code> функцията на елемента,
                  която ще върне shadow root обект, към който може след това да се добавят елементи.
                </p>
                <prism-highlighter></prism-highlighter>
                <marked-element>
                  <div class="markdown-html"></div>
                  <script type="text/markdown">
                    ```js
                    var host = document.querySelector('#host');
                    var root = host.createShadowRoot();
                    var div = document.createElement('div');
                    div.textContent = 'This is Shadow DOM';
                    root.appendChild(div);
                    ```
                    ```html
                    <div id="host"></div>
                    ```
                  </script>
                </marked-element>
                <p>Погледнат през dev tools резултата трябва да изглежда така:</p>
                <img class="responsive" src="images/shadow_dom_06.png" />
                <p>
                  Чрез добавяне на select атрибут с css селектор като стойност може да се вземе съдържанието елемента към който е добавен shadow
                  root и да се постави където и да е например.
                </p>
                <marked-element>
                  <div class="markdown-html"></div>
                  <script type="text/markdown">
                    ```js
                    var host = document.querySelector('#host');
                    var root = host.createShadowRoot();
                    var div = document.createElement('content');
                    content.setAttribute('select', 'h1');
                    root.appendChild(content);
                    ```
                    ```html
                    <div id="host">
                      <h1>This is shadow DOM</h1>
                    </div>
                    ```
                  </script>
                </marked-element>
                <p>
                  Това е възможно единствено за директните деца на host елемента.
                </p>
                <p>
                  Тъй като добавянето на съдържание чрез JavaScript не е толкова ефективно от към производителност, може да се използва и друг
                  подход. Това може да бъде постигнато като съчетание на template елементите и shadow DOM. Ще използваме
                  същото демо което разгледахме при template елементите, като единствената разлика е това, че ще добавим
                  content елемент който има атрибут select със стойност h1
                </p>
                <marked-element>
                  <div class="markdown-html"></div>
                  <script type="text/markdown">
                    <strong>HTML</strong>
                    ```html
                    <template id="template">
                        <style>
                        ...
                        </style>
                        <div id="container">
                            <img src="...">
                            <content select="h1"></content>
                        </div>
                    </template>
                    <div id="host">
                        <h1>This is shadow DOM</h1>
                    </div> 
                    ```
                    <strong>JavaScript:</strong>
                    ```js
                    var host = document.querySelector('#host');
                    var root = host.createShadowRoot();

                    var template = document.querySelector('#template');
                    var clone = document.importNode(template.content, true);
                    root.appendChild(clone);
                    ```
                  </script>
                </marked-element>
              </paper-material>
              <paper-material>
                <h2>Допълнителна информация</h2>
                <p>
                  Shadow DOM предоставя още много допълнителна функционалност, като стилизация, обработване на събития и управление на множество
                  shadow roots.
                </p>
                <p>Повече информация може да се намери на:</p>
                <ul>
                  <li>
                    <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/">Shadow DOM 101</a> [4]
                  </li>
                  <li>
                    <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/">Shadow DOM 201 CSS and Styling</a>                    [5]
                  </li>
                  <li>
                    <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-301/">Shadow DOM 301 Advanced Concepts & DOM APIs</a>                    [6]
                  </li>
                  <li>
                    <a href="http://code.tutsplus.com/tutorials/intro-to-shadow-dom--net-34966">Introduction to Shadow DOM</a>                    [7]
                  </li>
                  <li>
                    <a href="https://www.w3.org/TR/shadow-dom/">W3C - Shadow DOM</a> [8]
                  </li>
                </ul>
              </paper-material>
            </section>

            <section data-route="html-imports" tabindex="-1">
              <paper-material elavation="1">
                <h1 class="page-title" tabindex="-1">HTML Imports</h1>
                <p>Уеб компонентите позволяват изграждането на страхотни уеб сайтове чрез използването на преизползваеми компоненти.</p>
                <p>Но какво е нужно да се изгради уеб компонент?</p>
                <p>
                  Ако сте работили с UI библиотеки като jQuery UI или bootstrap сигурно знаете, че е нужно да се добавят множество от тагове
                  с необходими ресурси като скриптове, стилове или уеб шрифтове. Не би ли било хубаво, ако можеше да ги заредим
                  като компонент чрез един таг, защото все пак те представляват единен набор от функции и в повечето случаи
                  не могат да се използвам самостоятелно
                </p>
                <p>HTML импортите позволяват да заредим HTML файл, който включва в себе си, всички необходими ресурси, като
                  javascript скриптове и css стилизации.</p>
              </paper-material>
              <paper-material>
                <h2>Поддръжка</h2>
                <p>Към момента HTML импорт се поддържа от Chrome и Opera, както и чрез настройка на Firefox.</p>
                <p>За проверка дали се поддържа от текущия браузър може да се използва следния код:</p>
                <prism-highlighter></prism-highlighter>
                <marked-element>
                  <div class="markdown-html"></div>
                  <script type="text/markdown">
                    ```js
                   if(!'import' in document.createElement('link')){
                        ...
                    } 
                    ```
                  </script>
                </marked-element>
              </paper-material>
              <paper-material>
                <h2>Начин на използване</h2>
                <p>Използването на HTML импорти става чрез добавяне на link таг с атрибут rel="import"</p>
                <prism-highlighter></prism-highlighter>
                <marked-element>
                  <div class="markdown-html"></div>
                  <script type="text/markdown">
                    index.html:
                    ```html
                    <link rel="import" href="https://www.example.com/import.html"/>
                    ```
                    
                    В импортираните html файлове може да се заредят допълнителни ресурси като javascript и css
                    import.html:
                    ```html
                    <link rel="stylesheet" href="css/style.css"/>
                    <script src="js/script.js></script_>
                    ```
                  </script>
                </marked-element>
                <p>Не е нужно да се добавя doc type, head или body елемент в импортнатият HTML файл.</p>
                <p>Html импорта изпълнява скриптове, зарежда css стилове и шрифтове веднага след като импортираният html файл
                  е зареден.</p>
                <p>За да използваме тези ресурси през javascript, window и document обектите на импортираният документ са идентични
                  с тези от главният (index) документ.</p>
                <img src="images/html_imports_01.png" alt="html import window and dom object">

                <p>
                  Ако една страница използва множество уеб компоненти, тя може да заприлича на:
                </p>
                <marked-element>
                  <div class="markdown-html"></div>
                  <script type="text/markdown">
                    ```html
                    <link rel="import" href="polymer/polymer.html">
                    <link rel="import" href="core-component/core-component.html">
                    <link rel="import" href="core-icon/core-icon.html">
                    <link rel="import" href="core-icon-button/core-icon-button.html">
                    <link rel="import" href="core-toolbar/core-toolbar.html">
                    <link rel="import" href="core-header/core-header.html">
                    <link rel="import" href="core-submenu/core-submenu.html">
                    <link rel="import" href="core-item/core-item.html">
                    ...
                    ```
                  </script>
                </marked-element>
                <p>
                  Толкова много импорти могат да доведат до зареждането на множество ресурси, някои от които зависят от общи ресурси.
                </p>
                <marked-element>
                  <div class="markdown-html"></div>
                  <script type="text/markdown">
                    index.html:
                    ```html
                    <link rel="import" href="component1.html">
                    <link rel="import" href="component2.html">
                    ```
                    component1.html:
                    ```html
                    <link rel="import" href="jquery.html">
                    ```

                    component2.html:
                    ```html
                    <link rel="import" href="component1.html">
                    ```

                    jQuery.html
                    ```html
                    <script src="js/jquery.js"></script`>
                    ```
                  </script>
                </marked-element>

                <p>За щастие HTML импортите се грижат за това и повтарящите се ресурси се зареждат само по веднъж.</p>

                <p>
                  За да се подобри производителността на страницата броят на импорти трябва да се сведе до минимум.
                  <br> Съществува библиотека наречена <a href="https://github.com/Polymer/vulcanize">Vulcanize</a> [9] която
                  решава този проблем. Vulcanize рекурсивно обхожда всички html импорти, flat-ва техните зависимости и генерира
                  файл, който потенциално може да намали броя на заявки по мрежата.
                </p>

                <marked-element>
                  <div class="markdown-html"></div>
                  <script type="text/markdown">
                    Преди:
                    ```html
                    <link rel="import" href="polymer/polymer.html">
                    <link rel="import" href="core-component/core-component.html">
                    <link rel="import" href="core-icon/core-icon.html">
                    <link rel="import" href="core-icon-button/core-icon-button.html">
                    <link rel="import" href="core-toolbar/core-toolbar.html">
                    <link rel="import" href="core-header/core-header.html">
                    <link rel="import" href="core-submenu/core-submenu.html">
                    <link rel="import" href="core-item/core-item.html">
                    ...
                    ```
                    След:
                    ```html
                    <link rel="import" href="vulcanized.html">
                    ```
                  </script>
                </marked-element>
                <p>
                  Нека погледнем как HTML импортите работят като разширим демото което използвахме в предишните страници за Custom Elements,
                  Shadow Dom и Templates.
                </p>
                <p>Едно от преимуществата от използването на уеб компоненти е това, че компонент може да бъде изолиран и преизползван.
                  <br> HTML импортите помагат с това, че целият код на уеб компонента може да бъде изнесен в отделен файл,
                  например fmi.html
                  <br> В този файл ще се използват Custom елементи, Shadow DOM и template елементи.
                </p>
                <marked-element>
                  <div class="markdown-html"></div>
                  <script type="text/markdown">
                    fmi.html:
                    ```html
                    <template id="template">
                        <style>
                            ...
                        </style>
                        <div id="container">
                            <img src=".."
                            <content select="h1"></content>
                        </div>
                    </template>
                    <script>
                        var XComponent = document.registerElement('fmi', {
                        prototype: Object.create(HTMLElement.prototype, {
                                createdCallback: {
                                    var root = this.createShadowRoot();
                                    var template = document.querySelector('#template');
                                    var clone = document.importNode(template.content);
                                    root.appendChild(clone);
                                }
                            }
                        });
                    </script`>
                    ```

                    index.html:
                    ```html
                        ...
                        <link rel="import" href="fmi.html">
                    </head>
                    <body>
                        <fmi>
                            <h1>This is my Web Component</h1>
                        </fmi>
                        ...
                    ```
                  </script>
                </marked-element>
              </paper-material>
              <paper-material>
                <h2>Допълнителна информация</h2>
                <p>Повече информация за HTML импортите може да се намери на:</p>
                <ul>
                  <li>
                    <a href="http://www.html5rocks.com/en/tutorials/webcomponents/imports/">
                      HTML5Rocks - HTML Imports</a> [10]
                  </li>
                  <li>
                    <a href="https://w3c.github.io/webcomponents/spec/imports/">
                      W3C - HTML Imports [11]
                    </a>
                  </li>
                </ul>
              </paper-material>
            </section>

            <section data-route="browser-support" tabindex="-1">
              <paper-material elavation="1">
                <h1 class="page-title" tabindex="-1">Browser support and Polyfills</h1>
                <p>Към момента пълна поддръжка за уеб компоненти има в Chrome и Opera. Firefox предлага само частична такава.</p>
                <p>Уеб компонентите са нова технология и се развиват много бързо. Актуална информация за поддържаните браузъри
                  може да бъде намерена на следните страници:</p>
                <ul>
                  <li><a href="https://jonrimmer.github.io/are-we-componentized-yet/">Are We Componentized Yet?</a>[12]</li>
                  <li><a href="https://www.chromestatus.com/">Chrome Status</a>[13]</li>
                  <li><a href="http://webcomponents.org/">Webcomponents.org</a>[14]</li>
                  <li><a href="http://caniuse.com/#search=components">Can I Use - Web Components</a> [15]</li>
                </ul>
                <p>Няма причина уеб компонентите да не могат да бъдат използвани и днес. Както видяхме в примерите по-нагоре
                  големи компании като Github го използват в продукционна среда.
                </p>

                <p>Съществува официален polyfill поддържан от уеб компонент общността, който се поддържа на всички от широко
                  използваните браузъри</p>

                <p>Може да бъде намерен на <a href="https://github.com/WebComponents/webcomponentsjs">webcomponentsjs</a> [16]</p>

                <table>
                  <thead>
                    <tr>
                      <th>Polyfill</th>
                      <th>IE10</th>
                      <th>IE11+</th>
                      <th>Chrome*</th>
                      <th>Firefox*</th>
                      <th>Safari 7+*</th>
                      <th>Chrome Android</th>
                      <th>Mobile Safari</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>Custom Elements</td>
                      <td>~</td>
                      <td>✓</td>
                      <td>✓</td>
                      <td>✓</td>
                      <td>✓</td>
                      <td>✓</td>
                      <td>✓</td>
                    </tr>
                    <tr>
                      <td>HTML Imports</td>
                      <td>~</td>
                      <td>✓</td>
                      <td>✓</td>
                      <td>✓</td>
                      <td>✓</td>
                      <td>✓</td>
                      <td>✓</td>
                    </tr>
                    <tr>
                      <td>Shadow DOM</td>
                      <td>✓</td>
                      <td>✓</td>
                      <td>✓</td>
                      <td>✓</td>
                      <td>✓</td>
                      <td>✓</td>
                      <td>✓</td>
                    </tr>
                    <tr>
                      <td>Templates</td>
                      <td>✓</td>
                      <td>✓</td>
                      <td>✓</td>
                      <td>✓</td>
                      <td>✓</td>
                      <td>✓</td>
                      <td>✓</td>
                    </tr>
                  </tbody>
                </table>
              </paper-material>
            </section>

            <section data-route="resources" tabindex="-1">
              <paper-material elavation="1">
                <h1 class="page-title" tabindex="-1">Използвани източници</h1>
                <ul>
                  <li>[1] Eric Bidelman - "HTML's New Template Tag", published February 26th, 2013
                    <a href="http://www.html5rocks.com/en/tutorials/webcomponents/template/">http://www.html5rocks.com/en/tutorials/webcomponents/template/</a></li>
                  <li>[2] Eric Bidelman - Custom Elements - 
                    <a href="http://www.html5rocks.com/en/tutorials/webcomponents/customelements/">http://www.html5rocks.com/en/tutorials/webcomponents/customelements/</a>      
                  </li>
                  <li>[3] MDN - Custom Elements - 
                    <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Custom_Elements">https://developer.mozilla.org/en-US/docs/Web/Web_Components/Custom_Elements</a>                    </li>
                  <li>[4] Dominic Cooney - Shadow DOM 101 - published on January 4th, 2013 - 
                    <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/">http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/</a> </li>
                  <li>
                    [5] Eric Bidelman - Shadow DOM 201 CSS and Styling - published on March 15th, 2015, last updated on April 10th, 2014 - 
                    <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/">http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/</a>
                  </li>
                  <li>[6] Eric Bidelman - Shadow DOM 301 Advanced Concepts & DOM APIs - published : March 21st, 2013, updated: December 18th, 2013 - 
                      <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-301/">http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-301/</a>
                  </li>
                  <li>[7] Angraj Mangal - Introduction to Shadow DOM - published on December 20th 2013 - 
                    <a href="http://code.tutsplus.com/tutorials/intro-to-shadow-dom--net-34966 ">http://code.tutsplus.com/tutorials/intro-to-shadow-dom--net-34966 </a>
                  </li>
                  <li>[8] W3C - Shadow DOM - Working Draft June 1th 2016 -
                      <a href="https://www.w3.org/TR/shadow-dom/ ">https://www.w3.org/TR/shadow-dom/ </a>
                  </li>
                  <li>Polymer - Vulcanize - <a href="https://github.com/Polymer/vulcanize">https://github.com/Polymer/vulcanize</a></li>
                  <li>[10] Eric Bidelman - HTML Imports - published on November 11th, 2013, Updated on December 18th, 2013 - 
                    <a href="http://www.html5rocks.com/en/tutorials/webcomponents/imports/">http://www.html5rocks.com/en/tutorials/webcomponents/imports/</a>
                  </li>
                  <li>
                    [11] W3C - HTML Imports - Last update on June 1st, 2016 -
                    <a href="https://w3c.github.io/webcomponents/spec/imports/">https://w3c.github.io/webcomponents/spec/imports/</a>
                  </li>
                  <li>
                    [12] Are We Componentized Yet? - 
                    <a href="https://jonrimmer.github.io/are-we-componentized-yet/">https://jonrimmer.github.io/are-we-componentized-yet/</a>
                  </li>
                  <li></li>
                  <li></li>
                  <li></li>
                  <li></li>
                  <li></li>
                  <li></li>
                  <li></li>
                  <li></li>
                  <li></li>
                </ul>

              </paper-material>
            </section>

            <section data-route="about-me" tabindex="-1">
              <paper-material elavation="1">
                <h1 class="page-title" tabindex="-1">About me</h1>
              </paper-material>
            </section>

          </iron-pages>
        </div>
      </paper-scroll-header-panel>
    </paper-drawer-panel>

    <paper-toast id="toast">
      <span class="toast-hide-button" role="button" tabindex="0" onclick="app.$.toast.hide()">Ok</span>
    </paper-toast>

    <!-- Uncomment next block to enable Service Worker support (1/2) -->
    <!--
    <paper-toast id="caching-complete"
                 duration="6000"
                 text="Caching complete! This app will work offline.">
    </paper-toast>

    <platinum-sw-register auto-register
                          clients-claim
                          skip-waiting
                          base-uri="bower_components/platinum-sw/bootstrap"
                          on-service-worker-installed="displayInstalledToast">
      <platinum-sw-cache default-cache-strategy="fastest"
                         cache-config-file="cache-config.json">
      </platinum-sw-cache>
    </platinum-sw-register>
    -->

  </template>

  <!-- build:js scripts/app.js -->
  <script src="scripts/app.js"></script>
  <!-- endbuild-->
</body>

</html>